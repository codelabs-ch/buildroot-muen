#!/bin/sh


##########################################################################
#                                                                        #
#  Copyright (C) codelabs gmbh, Switzerland - all rights reserved        #
#                <https://www.codelabs.ch/>, <contact@codelabs.ch>       #
#                                                                        #
#  This program is free software: you can redistribute it and/or modify  #
#  it under the terms of the GNU General Public License as published by  #
#  the Free Software Foundation, either version 3 of the License, or     #
#  (at your option) any later version.                                   #
#                                                                        #
#  This program is distributed in the hope that it will be useful,       #
#  but WITHOUT ANY WARRANTY; without even the implied warranty of        #
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
#  GNU General Public License for more details.                          #
#                                                                        #
#  You should have received a copy of the GNU General Public License     #
#  along with this program.  If not, see <http://www.gnu.org/licenses/>. #
#                                                                        #
#                                                                        #
#    @contributors                                                       #
#        2019, 2021  David Loosli <dave@codelabs.ch>                     #
#                                                                        #
#                                                                        #
#    @description                                                        #
#        subjectcaesar script to communicate with a native subject       #
#        that encrypts a given string with the caesar cipher             #
#    @project                                                            #
#        MuenOnARM                                                       #
#    @interface                                                          #
#        Buildroot                                                       #
#    @target                                                             #
#        Xilinx UltraScale+ ZCU104 evaluation board                      #
#    @reference                                                          #
#        Linux Device Tree, Muen SK Channels and native driver with      #
#        simple protocol                                                 #
#                                                                        #
##########################################################################


##
# @name  default configuration
# @type  variable definitions
#
# @brief patch configurations for the different targets as
#        arrays (i.e. [<id><type>]="<origfile> <destfile>")
##

EXPORT_FILE=/var/subjectcaesar/global.dat
EXPORT_LOG=/var/subjectcaesar/global.log

SE_INITIALIZED=False
SE_READ_FLAG=0
SE_WRITE_FLAG=0

READ_CHANNEL=/dev/mrchan0
WRITE_CHANNEL=/dev/mwchan0
CHANNEL_SIZE=4096

READ_TIMEOUT_LIMIT=10
READ_TIMEOUT_COUNTER=0
WRITE_TIMEOUT_LIMIT=5
WRITE_TIMEOUT_COUNTER=0

KEY_VALUE=""
SECRET_MESSAGE=""
RESULT_MESSAGE=""

##
# @name  usage
# @type  function
#
# @brief prints the usage information for this script
##
usage()
{
	echo "usage: subjectcaesar -h | --help   |"
	echo "                     [-k <integer> | --key <integer>]"
	echo "                     [-s <string>  | --string <string>]"
	echo ""
	echo "  -h | --help     display usage info"
	echo ""
	echo "  -k | --key      an integer value between 0 and 99"
	echo ""
	echo "  -s | --string   the string the subject is going to encode"
	echo "                  with the cryptographically strongest cipher"
	echo "                  ever (Caesar Cipher) and the specified key"
	echo "                  on the specified read only channel (note:"
	echo "                  ASCII support only)"
	return 0
}

##
# @name  print_log
# @type  function
#
# @brief prints a log entry with a timestamp, a given title
#        and a given message
##
print_log()
{
	echo "[$(date "+%H:%M:%S")] ${1} - ${2}" >> ${EXPORT_LOG} || return 1
	return 0
}

##
# @name  error_exit
# @type  function
#
# @brief prints the passed error message and exits with the
#        given error code
##
error_exit()
{
    print_log "SUBJECTCAESAR" "script error: ${1:-"Unknown Error"}"
	exit ${2}
}

##
# @name  ready_to_receive
# @type  function
#
# @brief reads the header from the read channel and checks
#        if the subject has sent a new message
##
ready_to_receive()
{
    if [ $READ_TIMEOUT_COUNTER -ge $READ_TIMEOUT_LIMIT ]; then
        READ_TIMEOUT_COUNTER=0
        error_exit "timeout at line 117" 1
    fi

    SE_READ_FLAG=$(sed -n 's/^SE_READ_FLAG=//p' $EXPORT_FILE)
    SE_RF_CURRENT=$(dd bs=1 skip=0 count=1 if=${READ_CHANNEL} status=none | od -An -t d1 -N 1 | tr -d " ")

    if [ "$SE_READ_FLAG" == "$SE_RF_CURRENT" ]; then
        print_log "SUBJECTCAESAR" "no new message from subject received"
        READ_TIMEOUT_COUNTER=$(($READ_TIMEOUT_COUNTER+1))
        sleep 0.1
        return 1
    else
        SE_READ_FLAG=${SE_RF_CURRENT}
        sed -i "/^SE_READ_FLAG/s/=.*$/=${SE_READ_FLAG}/" $EXPORT_FILE
        print_log "SUBJECTCAESAR" "new message from subject received"
        return 0
    fi
}

##
# @name  read_message
# @type  function
#
# @brief reads the message from the read channel
##
read_message()
{
    while ! ready_to_receive; do : ; done

    MESSAGE_LENGTH=""

    for Index in 4 5 6 7; do
        TMP=$(dd bs=1 skip=${Index} count=5 if=${READ_CHANNEL} status=none | od -An -t x1 -N 1 | tr -d " ")
        MESSAGE_LENGTH="${TMP}${MESSAGE_LENGTH}"
    done

    MESSAGE_LENGTH=$(echo ${MESSAGE_LENGTH} | sed -e 'y/abcdef/ABCDEF/')
    MESSAGE_LENGTH=$(echo "ibase=16; ${MESSAGE_LENGTH}" | bc)
    RESULT_MESSAGE=$(dd bs=1 skip=8 count=${MESSAGE_LENGTH} if=${READ_CHANNEL} status=none)

    print_log "SUBJECTCAESAR" "Result Message: ${RESULT_MESSAGE}"
    return 0
}

##
# @name  ready_to_send
# @type  function
#
# @brief reads the header from the read channel and checks
#        if the subject is ready to receive a message
##
ready_to_send()
{
    if [ $WRITE_TIMEOUT_COUNTER -ge $WRITE_TIMEOUT_LIMIT ]; then
        WRITE_TIMEOUT_COUNTER=0
        error_exit "timeout at line 172" 1
    fi

    READY_CURRENT=$(dd bs=1 skip=1 count=1 if=${READ_CHANNEL} status=none | od -An -t d1 -N 1 | tr -d " ")

    if [ "$READY_CURRENT" == "1" ]; then
        print_log "SUBJECTCAESAR" "subject is ready to receive data"
        return 0
    else
        print_log "SUBJECTCAESAR" "subject not ready to receive data"
        WRITE_TIMEOUT_COUNTER=$(($WRITE_TIMEOUT_COUNTER+1))
        sleep 0.1
        return 1
    fi
}

##
# @name  write_message
# @type  function
#
# @brief writes the message to the write channel
##
write_message()
{
    while ! ready_to_send; do : ; done

    SE_WRITE_FLAG=$(sed -n 's/^SE_WRITE_FLAG=//p' $EXPORT_FILE)
    SE_WRITE_FLAG=$((($SE_WRITE_FLAG+1)%2))
    sed -i "/^SE_WRITE_FLAG/s/=.*$/=${SE_WRITE_FLAG}/" $EXPORT_FILE

    if [ ${#1} -gt ${CHANNEL_SIZE} ]; then
        error_exit "fragmentation not yet supported, message size over channel size at line 203" 2
    fi

    HEX_STRING=$(echo "obase=16; ${#1}" | bc)
    OFFSET=${#HEX_STRING}
    LENGTH_HEADER=""
    OFFSET_HEADER=4

    while [ $OFFSET_HEADER -gt 0 ]; do
        OFFSET=$(($OFFSET-2))
        case ${OFFSET} in
			[0-9])
				LENGTH_HEADER="${LENGTH_HEADER}\x${HEX_STRING:$OFFSET:2}"
				;;
            -1)
				LENGTH_HEADER="${LENGTH_HEADER}\x0${HEX_STRING:0:1}"
				;;
            *)
				LENGTH_HEADER="${LENGTH_HEADER}\x00"
				;;
        esac
        OFFSET_HEADER=$(($OFFSET_HEADER-1))
    done

    echo -n -e "\x0${SE_WRITE_FLAG}\x01\x00\x00${LENGTH_HEADER}${1}" > ${WRITE_CHANNEL}

    print_log "SUBJECTCAESAR" "writing ${1} with length ${#1}"
    return 0
}

##
# @name  initialize_communication
# @type  function
#
# @brief prints the passed error message and exits with the
#        given error code
##
initialize_communication()
{
    SE_INITIALIZED=$(sed -n 's/^SE_INITIALIZED=//p' $EXPORT_FILE)
    SE_READ_FLAG=$(sed -n 's/^SE_READ_FLAG=//p' $EXPORT_FILE)
    SE_WRITE_FLAG=$(sed -n 's/^SE_WRITE_FLAG=//p' $EXPORT_FILE)

    if [ "$SE_INITIALIZED" != "True" ]; then
        print_log "SUBJECTCAESAR" "initializing communication"

        RESULT_MESSAGE=$(dd bs=1 skip=8 count=5 if=${READ_CHANNEL} status=none)

        if [ "$RESULT_MESSAGE" == "Hello" ]; then
            echo -n -e "\x00\x01\x00\x00\x05\x00\x00\x00Hello" > ${WRITE_CHANNEL}
            sleep 0.1
            echo -n -e "\x00\x01\x00\x00\x05\x00\x00\x00Hello" > ${WRITE_CHANNEL}
            sed -i '/^SE_INITIALIZED/s/=.*$/=True/' $EXPORT_FILE
            print_log "SUBJECTCAESAR" "communication initialized"
        else
            error_exit "unknown protocol at line 265" 1
        fi
    else
        print_log "SUBJECTCAESAR" "communication already initialized"
    fi
}

##
# @name -
# @type script main
##
if [ $# -gt 4 ]; then
	print_log "SUBJECTCAESAR" "Illegal number of options. Please try again!"
	usage
	error_exit "at line ${1:-"279"}" 1
fi

if [ $# != 0 ]; then
	while test $# -gt 0; do
		case "$1" in

			-h|--help)
				usage
				exit 0
				;;

			-k|--key)
                shift
                if [ ${1} -lt 0 ] || [ ${1} -gt 99 ]; then
                    error_exit "illegal key not between 0 and 99 at line 295" 1
                fi
                if [ ${1} -lt 10 ]; then
                    KEY_VALUE="0${1}"
                else
                    KEY_VALUE="${1}"
                fi
                shift
				;;
	
			-s|--string)
                shift
                SECRET_MESSAGE="${1}"
                shift
                while [ "${1}" != "--key" ] && [ "${1}" != "" ]; do
                    SECRET_MESSAGE="${SECRET_MESSAGE} ${1}"
                    shift
                done
				;;

			*)
				print_log "SUBJECTCAESAR"  "Unknown option - please try again!"
				usage
				exit 1
				;;

		esac
	done
fi

if [ "${KEY_VALUE}" != "" ] && [ "${SECRET_MESSAGE}" != "" ]; then
    initialize_communication
    write_message "${KEY_VALUE}${SECRET_MESSAGE}"
    read_message
    echo "Received Message: ${RESULT_MESSAGE}"
    exit 0
else
    error_exit "empty values for key or secret message ${1:-"323"}" 1
fi

